!    DCDEXTRACT - Converts from dcd/dcde to dcd/dcde, extract frames, remove particles
!    Copyright (C) 2014 Pablo M. De Biase (pablodebiase@gmail.com)
!
!    This program is free software: you can redistribute it and/or modify
!    it under the terms of the GNU General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    (at your option) any later version.
!
!    This program is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU General Public License for more details.
!
!    You should have received a copy of the GNU General Public License
!    along with this program.  If not, see <http://www.gnu.org/licenses/>.

module comun
implicit none
integer*4 na,nsc,naw
integer*4 icntrl(20),itemp
character hdr*4
integer ntitle
character*1,allocatable :: title(:)
real*4,allocatable :: rc(:,:)
real*8 :: xtlabc6(6),xtlabc12(12)
logical*1 dcdopen,charmm
integer*4,allocatable :: list(:)
end module

program dcdextract
use comun
implicit none
character dcdinp*256,dcdout*256,yesno*1,line*256
integer*4 uni,uno,narg,fac,ifr,ffr,arg,a,b,exn,i
real*8 nv(3,3),cv(3,3),ie(3,3),ev(3,3),r(3,3)
real*4 rr(3,3)
character bs*8
logical*1 rotate,inpdcde,outdcde,dcde2dcd,dcd2dcde
logical*1,allocatable :: except(:)

bs=repeat(achar(8),len(bs))

narg=COMMAND_ARGUMENT_COUNT()
arg=0

call header()
call readarg('Input CHARMM dcd or dcde filename: ',narg,arg,dcdinp)
inpdcde=.false.
if (dcdinp(index(dcdinp,'.',back=.true.):len_trim(dcdinp)).eq.'.dcde') inpdcde=.true.
call readarg('Output CHARMM dcd or dcde trajectory filename: ',narg,arg,dcdout)
outdcde=.false.
if (dcdout(index(dcdout,'.',back=.true.):len_trim(dcdout)).eq.'.dcde') outdcde=.true.

uni=1
uno=2

!read charmm dcd head
call readdcdhead(dcdinp,uni,ffr)

dcde2dcd=inpdcde.and..not.outdcde
dcd2dcde=.not.inpdcde.and.outdcde
if (charmm) then 
  dcd2dcde=.false.
  dcde2dcd=.false.
endif
if (dcde2dcd) then
  call readarg('Center and Rotate positions accordingly to new vectors (y/n)? [y]: ',narg,arg,yesno)
  if (yesno.eq.'n'.or.yesno.eq.'N') then
    rotate=.false.
  else
    rotate=.true.
  endif
endif

call readarg('Write atoms from a [1]: ',narg,arg,line)
if (len_trim(line).eq.0) then
  a=1
else
  read(line,*) a
endif
call readarg('Write atoms to b ['//int2chr(na)//']: ',narg,arg,line)
if (len_trim(line).eq.0) then
  b=na
else
  read(line,*) b
endif
if (b.le.0.or.b.gt.na) b=na
if (a.le.0.or.a.gt.na.or.a.gt.b) a=1
write(*,'(A,I0,A,I0)') 'Writing from particle ',a,' to ',b


ifr=1
fac=1
call readarg('Initial Frame [ 1 ]: ',narg,arg,line)
if (len_trim(line).ne.0) read(line,*) ifr
call readarg('Final Frame ['//int2chr(ffr)//']: ',narg,arg,line)
if (len_trim(line).ne.0) read(line,*) ffr
call readarg('Saving Frequency [ 1 ]: ',narg,arg,line)
if (len_trim(line).ne.0) read(line,*) fac

allocate (except(na))
except=.true.
if (a.gt.1) except(1:a-1)=.false.
if (b.lt.na) except(b+1:na)=.false.
! ask for exceptions
write(*,'(/A)') 'Exceptions: '
read(*,'(A)') line
do while (len_trim(line).gt.0)
  read(line,*) exn
  except(exn)=.false.
  read(*,'(A)') line
enddo

! calc naw
naw=sum( (/ (1,i=1,na) /), mask = except)
write(*,'(/A,I0)') 'Total Number of particles to write: ',naw
! make list
allocate (list(naw))
list=pack( (/ (i,i=1,na) /), mask = except)

!hdr='CORD'
!itemp=2
!title='Generated by DCDEXTRACT - user PMD'
!icntrl=0
icntrl(1)=int((ffr-ifr+1)/fac)
!icntrl(2)=1
icntrl(3)=1
icntrl(4)=icntrl(1)
!icntrl(10)=1026003171
!icntrl(11)=1
!icntrl(20)=24

call writedcdhead(dcdout,uno)

! Print number of frames read
write(*,'(/A,I8$)') 'Frame: ',nsc

call readdcdbody(uni,inpdcde)
do while(dcdopen.and.nsc.le.ffr)
  if (nsc.ge.ifr.and.nsc.le.ffr.and.mod(nsc,fac).eq.0) then
    if (dcde2dcd) then
      call buildnv(xtlabc12(1:9),nv)     ! build NV matrix for next step
      call getcharmmvectors(nv,cv)       ! convert NV matrix to CV (charmm vectors matrix)
      if (rotate) then                   ! if rotate active to the following
        call mat2vec(cv,xtlabc6)         ! convert CV to charmm 6 array elements format
        call centerbox(xtlabc12(10:12))  ! center all atoms according to the defined center
        call vec2mat(xtlabc12(1:9),ev)   ! convert 12 array elements format (dcde) to a 3x3 matrix (EV)
        call pinv(ev,ie)                 ! compute the pseudoinverse matrix (EV to IE)
        r=matmul(cv,ie)                  ! multiply CV and IE to get the rotating matrix
        rr=sngl(r)                       ! convert R (real*8) to RR (real*4) matrix
        rc=matmul(rr,rc)                 ! multiply the rotating matrix with atom coordinates so rotating them
      endif
    elseif (dcd2dcde) then
      xtlabc12(10:12)=0d0
      xtlabc12(1)=xtlabc6(1)
      xtlabc12(2)=xtlabc6(2)
      xtlabc12(3)=xtlabc6(4)
      xtlabc12(4)=xtlabc6(2)
      xtlabc12(5)=xtlabc6(3)
      xtlabc12(6)=xtlabc6(5)
      xtlabc12(7)=xtlabc6(4)
      xtlabc12(8)=xtlabc6(5)
      xtlabc12(9)=xtlabc6(6)
    endif
    call writedcdbody(uno,outdcde)       ! write dcd coordinates and vectors
  endif
  write(*,'(A8,I8$)') bs,nsc           ! print frame number
  call readdcdbody(uni,inpdcde)        ! read dcde coordinates and vectors, close when finishes
enddo 
close(uno)                             ! close output file
  
write(*,'(//A)') 'Normal termination.'
contains
  function int2chr(inte)
  implicit none
  integer*4 inte
  character*(int(log10(float(inte)))+1) int2chr
  write(int2chr,'(I0)') inte
  end function
end program

! program output header
subroutine header()
implicit none
character prname*64,prver*32,prdesc*256,startdate*32,lastdate*32,author*64

prname='DCDEXTRACT'
prver='version 1.5'
prdesc='Converts from dcd/dcde to dcd/dcde, extract frames, remove particles'
author='Pablo M. De Biase (pablodebiase@gmail.com)'
startdate='19 Apr 2011'
lastdate='23 Oct 2012'

write(*,'(/A)') trim(prname)//' '//trim(prver)
write(*,'(A)') trim(prdesc)
write(*,'(A/)') '      created by '//trim(author)//' since '//trim(startdate)//' and last modified '//trim(lastdate)
end subroutine

! read arguments
subroutine readarg(ques,narg,num,text)
implicit none
integer*4 narg,num
character text*(*),ques*(*)

num=num+1
write(*,'(/A$)') ques
if (narg.ge.num) then
  call GET_COMMAND_ARGUMENT(num,text)
  write(*,'(A)') trim(text)
else
  read(*,'(A)') text
endif
text=adjustl(trim(text))
end subroutine

subroutine buildnv(vec,mat)
implicit none
real*8 vec(9),mat(3,3)
mat(1,1)=dot_product(vec(1:3),vec(1:3))
mat(2,2)=dot_product(vec(4:6),vec(4:6))
mat(3,3)=dot_product(vec(7:9),vec(7:9))
mat(1,2)=dot_product(vec(1:3),vec(4:6))
mat(2,1)=mat(1,2)
mat(1,3)=dot_product(vec(1:3),vec(7:9))
mat(3,1)=mat(1,3)
mat(2,3)=dot_product(vec(4:6),vec(7:9))
mat(3,2)=mat(2,3)
end subroutine

subroutine vec2mat(vec,mat)
implicit none
real*8 vec(9),mat(3,3)
mat(1,1)=vec(1)
mat(2,1)=vec(2)
mat(3,1)=vec(3)
mat(1,2)=vec(4)
mat(2,2)=vec(5)
mat(3,2)=vec(6)
mat(1,3)=vec(7)
mat(2,3)=vec(8)
mat(3,3)=vec(9)
end subroutine

subroutine mat2vec(mat,vec)
implicit none
real*8 vec(6),mat(3,3)
vec(1)=mat(1,1)
vec(2)=mat(1,2)
vec(3)=mat(2,2)
vec(4)=mat(1,3)
vec(5)=mat(2,3)
vec(6)=mat(3,3)
end subroutine

subroutine centerbox(o)
use comun
implicit none
integer*4 i
real*8 o(3)
real*4 oo(3)
oo=sngl(o)

do i=1,na
  rc(1,i)=rc(1,i)-oo(1)
  rc(2,i)=rc(2,i)-oo(2)
  rc(3,i)=rc(3,i)-oo(3)
enddo

end subroutine

subroutine getcharmmvectors(nv,cv)
implicit none
integer*4 i
real*8 v(3,3),nv(3,3),cv(3,3)
real*8 ss(3,3),ms(3,3)!,pi,dr

! calculo de autovalores y autovectores de a
call diag(nv,3,ss,v)

! square root eigenvalues
ms=0d0
do i=1,3
  ms(i,i)=dsqrt(ss(i,i))
enddo

cv=matmul(v,ms)
cv=matmul(cv,transpose(v))
! CV = V*S*Vt

!write(*,*) 'Vectors as defined by Charmm: '
!write(*,*) 'a: ',cv(1,1:3)
!write(*,*) 'b: ',cv(2,1:3)
!write(*,*) 'c: ',cv(3,1:3)
end subroutine

subroutine pinv(mat,imat)
implicit none
integer*4 i
real*8 mat(3,3),imat(3,3),tmat(3,3),ss(3,3),vv(3,3),s(3,3)

tmat=matmul(transpose(mat),mat) ! A = Rt*R
call diag(tmat,3,ss,vv)         ! A = V*S2*Vt
s=0d0
do i=1,3                        
  s(i,i)=1d0/ss(i,i)     ! S^2 -> S^-2
enddo
! U = R*V*S-1
! Ut= S-1*Vt*Rt
! R-1 = V*S-1*Ut
! R-1 = V*S-2*Vt*Et
imat=matmul(vv,s)   ! V*S-2            
imat=matmul(imat,transpose(vv))
imat=matmul(imat,transpose(mat))
end subroutine
           
subroutine readdcdhead(dcdfile,un,fff)
use comun
implicit none
integer*4 kode,un,fff
integer*4 nfile,npriv,nsavc,nstep,nfree
character dcdfile*256

open(unit=un,file=dcdfile,form='unformatted')
dcdopen=.true.
read(un) hdr,icntrl
ntitle=icntrl(20)/12*80
if (allocated(title)) deallocate (title)
allocate (title(ntitle))
title=''
read(un,iostat=kode) itemp,title
read(un) na
write(*,*) hdr,icntrl
write(*,*) itemp,title
write(*,*) na
nfile=icntrl(1)
npriv=icntrl(2)
nsavc=icntrl(3)
nstep=icntrl(4)
if(icntrl(9).gt.0) print *, '# fixed atoms = ',icntrl(9)
nfree = na-icntrl(9)
print *, '# of free atoms = ',nfree
print *, 'total # atom = ', na,nstep,nsavc
charmm=.false.
if (icntrl(2).eq.0) charmm=.true.
if (nstep.le.0) nstep=1
if (nsavc.le.0) nsavc=1
nsc = nstep/nsavc

allocate (rc(3,na))
write(*,'(A,I0)') 'Total number of frames: ',nsc
fff=nsc
nsc=0
end subroutine

subroutine readdcdbody(un,dcde)
use comun
implicit none
integer*4 kode,i,un
logical*1 dcde
if (dcde) then
  read(un,iostat=kode) xtlabc12
else
  if (charmm) then
    xtlabc6=0d0
  else
    read(un,iostat=kode) xtlabc6
  endif
endif
read(un,iostat=kode) (rc(1,i),i=1,na)
read(un,iostat=kode) (rc(2,i),i=1,na)
read(un,iostat=kode) (rc(3,i),i=1,na)
if (kode.eq.0) then
  nsc=nsc+1
else
  close(un)
  dcdopen=.false.
endif
end subroutine

subroutine writedcdhead(dcdfile,un)
use comun
implicit none
integer*4 un
character dcdfile*256

open(unit=un,file=dcdfile,form='unformatted')
write(un) hdr,icntrl
write(un) itemp,title
write(un) naw

end subroutine

subroutine writedcdbody(un,dcde)
use comun
implicit none
integer*4 un,i
logical*1 dcde

if (.not.charmm) then
  if (dcde) then
    write(un) xtlabc12
  else
    write(un) xtlabc6
  endif
endif
write(un) (rc(1,list(i)),i=1,naw)
write(un) (rc(2,list(i)),i=1,naw)
write(un) (rc(3,list(i)),i=1,naw)
end subroutine

subroutine diag(a,np,ms,v)
implicit none
integer*4 np,i
double precision a(np,np),s(np),ms(np,np),v(np,np),e(np)

v=a
ms=0d0
s=0d0
call tred2(v,3,s,e)
call tqli(s,e,3,v)

do i=1,np
  ms(i,i)=s(i)
enddo 

end subroutine

subroutine tred2(a,np,d,e)
implicit none
integer*4 np,n,i,l,k,j
double precision a(np,np),d(np),e(np),h,f,g,hh,scale
n=np
if(n.gt.1)then
  do 18 i=n,2,-1  
    l=i-1
    h=0d0
    scale=0d0
    if(l.gt.1)then
      do 11 k=1,l
        scale=scale+abs(a(i,k))
11    continue
      if(scale.eq.0d0)then
        e(i)=a(i,l)
      else
        do 12 k=1,l
          a(i,k)=a(i,k)/scale
          h=h+a(i,k)**2
12      continue
        f=a(i,l)
        g=-sign(dsqrt(h),f)
        e(i)=scale*g
        h=h-f*g
        a(i,l)=f-g
        f=0d0
        do 15 j=1,l
          a(j,i)=a(i,j)/h
          g=0d0
          do 13 k=1,j
            g=g+a(j,k)*a(i,k)
13        continue
          if(l.gt.j)then
            do 14 k=j+1,l
              g=g+a(k,j)*a(i,k)
14          continue
          endif
          e(j)=g/h
          f=f+e(j)*a(i,j)
15      continue
        hh=f/(h+h)
        do 17 j=1,l
          f=a(i,j)
          g=e(j)-hh*f
          e(j)=g
          do 16 k=1,j
            a(j,k)=a(j,k)-f*e(k)-g*a(i,k)
16        continue
17      continue
      endif
    else
      e(i)=a(i,l)
    endif
    d(i)=h
18 continue
endif
d(1)=0d0
e(1)=0d0
do 23 i=1,n
  l=i-1
  if(d(i).ne.0d0)then
    do 21 j=1,l
      g=0d0
      do 19 k=1,l
        g=g+a(i,k)*a(k,j)
19    continue
      do 20 k=1,l
        a(k,j)=a(k,j)-g*a(k,i)
20    continue
21  continue
  endif
  d(i)=a(i,i)
  a(i,i)=1d0
  if(l.ge.1)then
    do 22 j=1,l
      a(i,j)=0d0
      a(j,i)=0d0
22  continue
  endif
23 continue
return
end subroutine

subroutine tqli(d,e,np,z)
implicit none
integer*4 np,n,i,l,iter,m,k
double precision d(np),e(np),z(np,np),dd,g,r,s,c,p,f,b
n=np
if (n.gt.1) then
  do 11 i=2,n
    e(i-1)=e(i)
11  continue
  e(n)=0d0
  do 15 l=1,n
    iter=0
1    do 12 m=l,n-1
      dd=abs(d(m))+abs(d(m+1))
      if (abs(e(m))+dd.eq.dd) go to 2
12    continue
    m=n
2    if(m.ne.l)then
      if(iter.eq.30) stop 'too many iterations'
      iter=iter+1
      g=(d(l+1)-d(l))/(2d0*e(l))
      r=dsqrt(g**2+1d0)
      g=d(m)-d(l)+e(l)/(g+sign(r,g))
      s=1d0
      c=1d0
      p=0d0
      do 14 i=m-1,l,-1
        f=s*e(i)
        b=c*e(i)
        if(abs(f).ge.abs(g))then
          c=g/f
          r=dsqrt(c**2+1d0)
          e(i+1)=f*r
          s=1d0/r
          c=c*s
        else
          s=f/g
          r=dsqrt(s**2+1d0)
          e(i+1)=g*r
          c=1d0/r  
          s=s*c
        endif
        g=d(i+1)-p
        r=(d(i)-g)*s+2d0*c*b
        p=s*r
        d(i+1)=g+p
        g=c*r-b
        do 13 k=1,n
          f=z(k,i+1)
          z(k,i+1)=s*z(k,i)+c*f
          z(k,i)=c*z(k,i)-s*f
13        continue
14      continue
      d(l)=d(l)-p
      e(l)=g
      e(m)=0d0
      go to 1
    endif
15  continue
endif
return
end subroutine
